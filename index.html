<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>280Thread</title>
    <link rel="icon" href="https://raw.githubusercontent.com/panwyyt/280Thread/refs/heads/main/Hathedboy.ico" type="image/x-icon">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for dark mode are applied via Tailwind dark: prefixes */

        /* Simple scrollbar styling */
        .scrollbar-thin {
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.5) rgba(243, 244, 246, 0.1); /* gray-400/50 gray-100/10 */
        }
        .dark .scrollbar-thin {
             scrollbar-color: rgba(107, 114, 128, 0.5) rgba(55, 65, 81, 0.5); /* gray-500/50 gray-700/50 */
        }
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(243, 244, 246, 0.1); /* gray-100/10 */
            border-radius: 4px;
        }
        .dark .scrollbar-thin::-webkit-scrollbar-track {
             background: rgba(55, 65, 81, 0.5); /* gray-700/50 */
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5); /* gray-400/50 */
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
         .dark .scrollbar-thin::-webkit-scrollbar-thumb {
             background-color: rgba(107, 114, 128, 0.5); /* gray-500/50 */
         }
         /* Utility for inline SVGs */
         .icon {
             display: inline-block;
             vertical-align: middle; /* Adjust alignment as needed */
             width: 1.25em; /* Default size, matches font-size */
             height: 1.25em;
         }
         .icon-sm { width: 1em; height: 1em; }
         .icon-xs { width: 0.875em; height: 0.875em; }

         /* Base input styling (can be overridden by dark mode) */
         .input-bg {
             background-color: white;
             border-color: #d1d5db; /* gray-300 */
             color: #111827; /* gray-900 */
         }
         .dark .input-bg {
             background-color: #374151; /* gray-700 */
             border-color: #4b5563; /* gray-600 */
             color: #f9fafb; /* gray-50 */
         }
         .input-bg:focus {
              border-color: #3b82f6; /* blue-500 */
              --tw-ring-color: #3b82f6; /* blue-500 */
              box-shadow: 0 0 0 2px var(--tw-ring-color);
         }
          .dark .input-bg:focus {
              border-color: #60a5fa; /* blue-400 */
              --tw-ring-color: #60a5fa; /* blue-400 */
              box-shadow: 0 0 0 2px var(--tw-ring-color);
            }

            /* Base text colors (can be overridden by dark mode) */
            body { color: #1f2937; /* gray-800 */ }
            .text-primary { color: #2563eb; /* blue-600 */ }
            .text-secondary { color: #374151; /* gray-700 */ }
            .text-muted { color: #6b7280; /* gray-500 */ }
            .container-bg { background-color: white; }
            .border-color { border-color: #e5e7eb; /* gray-200 */ }
            .modal-bg { background-color: white; }
            .modal-overlay-bg { background-color: rgba(0, 0, 0, 0.6); }
            .text-warning { color: #ef4444; /* red-500 */ }

            /* Dark mode overrides */
            .dark body { color: #d1d5db; /* gray-300 */ }
            .dark .text-primary { color: #60a5fa; /* blue-400 */ }
            .dark .text-secondary { color: #d1d5db; /* gray-300 */ }
            .dark .text-muted { color: #9ca3af; /* gray-400 */ }
            .dark .container-bg { background-color: #1f2937; /* gray-800 */ }
            .dark .border-color { border-color: #4b5563; /* gray-600 */ }
            .dark .modal-bg { background-color: #374151; /* gray-700 */ }
            .dark .modal-overlay-bg { background-color: rgba(0, 0, 0, 0.7); }
            .dark .text-warning { color: #f87171; /* red-400 */ }

        /* --- NEW Image Preview Styles --- */
        .image-thumbnail-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem; /* 8px */
            margin-top: 0.5rem; /* 8px */
        }
        .image-thumbnail-item {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 0.375rem; /* 6px */
            overflow: hidden;
            border: 1px solid #e5e7eb; /* gray-200 */
        }
        .dark .image-thumbnail-item {
            border-color: #4b5563; /* gray-600 */
        }
        .image-thumbnail-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .remove-image-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
            border: 1px solid white;
            line-height: 1; /* Important for small buttons */
						font-size: 10px; /* Smaller X */
        }
        .remove-image-btn svg { /* Style SVG directly if needed */
             width: 10px;
             height: 10px;
        }

        /* --- NEW Twitter Mockup Preview Styles --- */
        .tweet-preview-mockup {
            background-color: #ffffff; /* Twitter light bg */
            border: 1px solid #e5e7eb; /* gray-200 */
						border-radius: 0.75rem; /* 12px */
            padding: 0.75rem; /* 12px */
            margin-bottom: 0.75rem; /* 12px */
						font-family: "TwitterChirp", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
						/* ^ Add Twitter font stack if desired, otherwise falls back */
        }
        .dark .tweet-preview-mockup {
            background-color: #1f2937; /* Your dark bg */
            border-color: #4b5563; /* gray-600 */
        }
				.tweet-mockup-header {
						display: flex;
						align-items: flex-start;
						gap: 0.75rem; /* 12px */
						margin-bottom: 0.5rem; /* 8px */
				}
				.tweet-mockup-avatar img {
						width: 48px;
						height: 48px;
						border-radius: 9999px; /* Full circle */
				}
				.tweet-mockup-author {
						flex-grow: 1;
				}
				.tweet-mockup-name {
						font-weight: 700;
						color: #0f1419; /* Twitter black */
				}
				.dark .tweet-mockup-name {
						color: #e7e9ea; /* Twitter light gray */
				}
				.tweet-mockup- Pusername {
						color: #536471; /* Twitter gray */
						font-size: 0.9375rem; /* ~15px */
				}
				.dark .tweet-mockup-username {
						color: #71767b;
				}
				.tweet-mockup-content p {
						color: #0f1419;
						font-size: 0.9375rem; /* ~15px */
						line-height: 1.3125; /* Twitter line height */
						white-space: pre-wrap; /* Preserve line breaks */
            word-wrap: break-word; /* Break long words */
				}
				.dark .tweet-mockup-content p {
						color: #e7e9ea;
				}
				.tweet-mockup-images {
						margin-top: 0.75rem; /* 12px */
						border-radius: 0.75rem; /* 12px */
						overflow: hidden;
						border: 1px solid #cfd9de; /* Twitter image border light */
				}
				.dark .tweet-mockup-images {
						border-color: #38444d; /* Twitter image border dark */
				}
				.tweet-mockup-images-grid {
						display: grid;
						gap: 2px; /* Small gap between images */
				}
				.tweet-mockup-images-grid img {
						width: 100%;
						height: 100%;
						object-fit: cover;
            aspect-ratio: 1 / 1; /* Default square ratio */
				}
        /* Specific Grid Layouts */
				.image-count-1 .tweet-mockup-images-grid { grid-template-columns: 1fr; }
        .image-count-1 .tweet-mockup-images-grid img { aspect-ratio: 16 / 9; } /* Adjust aspect for single image */
				.image-count-2 .tweet-mockup-images-grid { grid-template-columns: 1fr 1fr; }
        .image-count-2 .tweet-mockup-images-grid img { aspect-ratio: 1 / 1; }
				.image-count-3 .tweet-mockup-images-grid { grid-template-columns: 1fr 1fr; }
        .image-count-3 .tweet-mockup-images-grid > *:nth-child(1) { grid-row: span 2; aspect-ratio: 1 / 2; } /* First image tall */
        .image-count-3 .tweet-mockup-images-grid > *:nth-child(2) { aspect-ratio: 1 / 1; }
        .image-count-3 .tweet-mockup-images-grid > *:nth-child(3) { aspect-ratio: 1 / 1; }
				.image-count-4 .tweet-mockup-images-grid { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;}
        .image-count-4 .tweet-mockup-images-grid img { aspect-ratio: 1 / 1; }

    </style>
    <script>
        // Basic Tailwind config for v4 browser build
        tailwind.config = {
          darkMode: 'class', // Enable dark mode using a class
          theme: {
            extend: {
              fontFamily: {
                sans: ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'], // Set Inter as primary sans-serif font
              },
            }
          }
        }
        // Function to apply saved theme preference (Uses localStorage)
        function applyTheme() {
            console.log("Applying theme..."); // DEBUG
            const themeToggleBtn = document.getElementById('themeToggle');
            if (!themeToggleBtn) {
                console.error("Theme toggle button not found during applyTheme.");
                return;
            }

            // Keep theme in localStorage - it's simple and sufficient
            const isDarkMode = localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches);

            if (isDarkMode) {
                document.documentElement.classList.add('dark');
                // Set Sun SVG
                themeToggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon w-5 h-5"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`;
                console.log("Theme set to dark."); // DEBUG
            } else {
                document.documentElement.classList.remove('dark');
                 // Set Moon SVG
                themeToggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon w-5 h-5"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`;
                console.log("Theme set to light."); // DEBUG
            }
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans flex justify-center items-start min-h-screen p-4 transition-colors duration-300">
    <div id="appContainer" class="container-bg w-full max-w-2xl rounded-lg shadow-lg p-4 sm:p-6 md:p-8 relative transition-colors duration-300">

        <button id="themeToggle" title="Toggle Theme" class="absolute top-4 right-4 text-gray-500 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 transition-colors duration-200 p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
            </button>

        <div class="text-center mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-primary mb-1">280Thread</h1>
            <p class="text-sm text-muted">
                Made with ❤️ by
                <a href="https://x.com/hatchedboy" target="_blank" rel="noopener noreferrer"
                   class="px-1.5 py-0.5 rounded no-underline hover:opacity-80 transition-opacity
                          text-gray-900 bg-yellow-300 dark:text-yellow-300 dark:bg-gray-700">
                    Hatchedboy
                </a>
            </p>
        </div>

        <div id="notificationArea" class="mb-4 text-center text-sm font-medium min-h-[1.25rem]"></div>

        <div class="mb-4">
            <label for="threadTitle" class="block text-sm font-medium text-secondary mb-1">Thread Title</label>
            <input type="text" id="threadTitle" class="input-bg w-full p-2 border rounded-md shadow-sm transition-colors duration-300" placeholder="Enter a title for your thread">
        </div>

        <div class="mb-6">
            <label for="threadConcept" class="block text-sm font-medium text-secondary mb-1">Thread Concept</label>
            <textarea id="threadConcept" class="input-bg w-full p-2 border rounded-md shadow-sm transition-colors duration-300" placeholder="Briefly describe the main idea of your thread" rows="3"></textarea>
        </div>

        <div id="tweetContainer" class="space-y-4 mb-6">
            <!-- Tweet elements will be inserted here -->
        </div>

        <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-6">
            <button id="addTweetBtn" class="btn bg-blue-600 hover:bg-blue-700">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="16"/><line x1="8" x2="16" y1="12" y2="12"/></svg>
                Add Tweet
            </button>
            <button id="saveThreadBtn" class="btn bg-green-600 hover:bg-green-700">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                 Export TXT
            </button>
            <button id="importThreadBtn" class="btn bg-purple-600 hover:bg-purple-700">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><path d="M14 2v6h6"/><path d="M4 12.5V16a2 2 0 0 0 2 2h1"/><path d="M11 18h-1a2 2 0 0 0-2 2v2"/><path d="M7 18a5 5 0 0 1 5-5v0a5 5 0 0 1 5 5v0"/><path d="M12 13v6"/><path d="m9 16 3-3 3 3"/></svg>
                 Import TXT
            </button>
            <button id="saveToLibraryBtn" class="btn bg-yellow-500 hover:bg-yellow-600 text-black dark:hover:bg-yellow-600">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
                 Save to Library
            </button>
            <button id="openLibraryBtn" class="btn bg-indigo-600 hover:bg-indigo-700">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/></svg>
                 Manage Library
            </button>
            <button id="clearAllBtn" class="btn bg-red-600 hover:bg-red-700">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon mr-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                 Clear All
            </button>
        </div>

        <div class="mb-4">
            <h3 class="text-lg font-semibold text-secondary mb-2">Preview (Twitter Mock-up)</h3>
						<!-- Changed preview container -->
            <div id="previewContainer" class="bg-gray-100 dark:bg-gray-800 border border-color rounded-md p-4 max-h-96 overflow-y-auto space-y-3 transition-colors duration-300 scrollbar-thin">
                <p class="text-muted italic text-center">Add tweets (and maybe images!) to see the preview.</p>
            </div>
        </div>
    </div>

    <!-- Library Modal (No changes needed here) -->
    <div id="libraryModal" class="fixed inset-0 modal-overlay-bg hidden justify-center items-center p-4 z-50 transition-opacity duration-300">
        <div class="modal-bg rounded-lg shadow-xl p-6 w-full max-w-2xl max-h-[85vh] overflow-y-auto relative transition-colors duration-300 scrollbar-thin">
            <button id="closeLibraryBtn" title="Close Library" class="absolute top-3 right-3 text-gray-500 dark:text-gray-400 hover:text-red-600 dark:hover:text-red-400 transition-colors duration-200 p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon w-5 h-5"><line x1="18" x2="6" y1="6" y2="18"/><line x1="6" x2="18" y1="6" y2="18"/></svg>
            </button>
            <h2 class="text-2xl font-semibold text-primary mb-4">Thread Library</h2>
            <div id="libraryContainer" class="space-y-6 mb-6">
                <p class="text-muted italic text-center">Your saved threads will appear here.</p>
            </div>
            <div class="flex flex-wrap gap-3 justify-end border-t border-color pt-4 mt-auto">
                <button id="exportLibraryBtn" class="btn btn-sm bg-green-600 hover:bg-green-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm mr-1"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/></svg>
                    Export All
                </button>
                <button id="importLibraryBtnModal" class="btn btn-sm bg-purple-600 hover:bg-purple-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm mr-1"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><path d="M14 2v6h6"/><path d="M4 12.5V16a2 2 0 0 0 2 2h1"/><path d="M11 18h-1a2 2 0 0 0-2 2v2"/><path d="M7 18a5 5 0 0 1 5-5v0a5 5 0 0 1 5 5v0"/><path d="M12 13v6"/><path d="m9 16 3-3 3 3"/></svg>
                    Import All
                </button>
            </div>
        </div>
    </div>

    <!-- Hidden File Inputs -->
    <input type="file" id="importThreadFile" class="hidden" accept=".txt">
    <input type="file" id="importLibraryFile" class="hidden" accept=".json">

    <script>
        // Constants
        const MAX_TWEET_LENGTH = 280;
        const MAX_IMAGES_PER_TWEET = 4;
        const DB_NAME = '280ThreadDB';
        const DB_VERSION = 1; // Keep version 1 unless schema changes
        const LIBRARY_STORE_NAME = 'threads'; // Stores { title: string, versions: Array<ThreadVersion> }
        const AUTOSAVE_STORE_NAME = 'autosave'; // Stores { id: 'currentDraft', data: ThreadData }
        const AUTOSAVE_KEY = 'currentDraft';

        // Global State
        let library = {}; // In-memory cache of the library, loaded from DB
        let tweetImages = {}; // { tweetElementId: [dataUrl1, dataUrl2, ...] } - NEW storage for image dataURLs
        let notificationTimeout; // Store timeout ID for notifications
        let dbPromise; // Holds the promise for the IndexedDB connection

        // DOM Elements (cache references on load)
        let threadTitleInput, threadConceptInput, tweetContainer, previewContainer,
            libraryModal, libraryContainer, importThreadFileInput, importLibraryFileInput,
            notificationArea, themeToggleBtn;

        // --- IndexedDB Helper Functions (No changes needed) ---
        function openDB() {
            if (!dbPromise) {
                console.log(`Opening IndexedDB: ${DB_NAME} v${DB_VERSION}`); // DEBUG
                dbPromise = new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error("IndexedDB error:", event.target.error);
                        reject("Error opening IndexedDB.");
                    };

                    request.onsuccess = (event) => {
                        console.log("IndexedDB opened successfully."); // DEBUG
                        resolve(event.target.result);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("IndexedDB upgrade needed."); // DEBUG
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(LIBRARY_STORE_NAME)) {
                            console.log(`Creating object store: ${LIBRARY_STORE_NAME}`); // DEBUG
                            db.createObjectStore(LIBRARY_STORE_NAME, { keyPath: 'title' });
                        }
                        if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
                            console.log(`Creating object store: ${AUTOSAVE_STORE_NAME}`); // DEBUG
                            db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                });
            }
            return dbPromise;
        }

        async function saveToDB(storeName, data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data); // Use put for insert/update

                request.onsuccess = () => resolve();
                request.onerror = (event) => { reject(`Error saving data to ${storeName}.`); }
            });
        }

        async function loadFromDB(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result); // Returns the object or undefined
                request.onerror = (event) => { reject(`Error loading data from ${storeName}.`); }
            });
        }

        async function loadAllFromDB(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result || []); // Returns array of objects
                request.onerror = (event) => { reject(`Error loading all data from ${storeName}.`); }
            });
        }

        async function deleteFromDB(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = (event) => { reject(`Error deleting data from ${storeName}.`); }
            });
        }

        async function clearStoreDB(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                 request.onsuccess = () => resolve();
                request.onerror = (event) => { reject(`Error clearing store ${storeName}.`); }
            });
        }

        // --- Notification Function (No changes) ---
        function showNotification(message, type = 'success', duration = 3000) {
             // console.log(`Showing notification: ${message} (Type: ${type})`); // DEBUG
             if (!notificationArea) return;
             if (notificationTimeout) clearTimeout(notificationTimeout);
             notificationArea.textContent = message;
             notificationArea.className = `mb-4 text-center text-sm font-medium min-h-[1.25rem] transition-opacity duration-300 ease-in-out ${
                 type === 'success' ? 'text-green-600 dark:text-green-400' :
                 type === 'error' ? 'text-red-600 dark:text-red-400' :
                 'text-blue-600 dark:text-blue-400' // info default
             }`;
             requestAnimationFrame(() => { notificationArea.style.opacity = 1; });
             notificationTimeout = setTimeout(() => { notificationArea.style.opacity = 0; }, duration);
         }


        // --- Tweet Element Creation & Management (MODIFIED) ---

        // NEW: Helper to get images for a tweet element ID
        function getImagesForTweet(tweetId) {
            return tweetImages[tweetId] || [];
        }

        // NEW: Helper to set images for a tweet element ID
        function setImagesForTweet(tweetId, imagesDataUrls) {
            tweetImages[tweetId] = imagesDataUrls || [];
            // Ensure autosave and preview update when images change
            autoSave();
            updatePreview();
        }

        // MODIFIED: createTweetElement to handle initial images
        function createTweetElement(tweetData = { text: '', images: [] }, index) {
            // console.log(`Creating tweet element at index ${index === undefined ? 'end' : index}`, tweetData); // DEBUG
            if (!tweetContainer) return null;

            const tweetId = `tweet-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`; // Unique ID
            const tweetElement = document.createElement('div');
            tweetElement.id = tweetId;
            tweetElement.className = 'tweet-container border border-color rounded-md p-4 relative transition-colors duration-300';

            // Inner HTML structure INCLUDING image elements
            tweetElement.innerHTML = `
                <textarea class="input-bg w-full p-2 border rounded-md shadow-sm transition-colors duration-300 resize-vertical min-h-[80px] tweet-text" placeholder="Write your tweet (${MAX_TWEET_LENGTH} chars max)" rows="4">${tweetData.text || ''}</textarea>
                <div class="text-xs text-right mt-1 text-muted character-count">${(tweetData.text || '').length}/${MAX_TWEET_LENGTH}</div>

                <!-- Image Upload Section -->
                <div class="mt-3 pt-3 border-t border-color">
                    <div class="flex items-center justify-between">
                        <button title="Add Image (up to ${MAX_IMAGES_PER_TWEET})" class="add-image-button btn-icon p-1 rounded-full text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
                        </button>
                        <input type="file" class="hidden image-file-input" accept="image/png, image/jpeg, image/gif, image/webp" multiple>
                        <span class="text-xs text-muted image-count-indicator">0/${MAX_IMAGES_PER_TWEET} images</span>
                    </div>
                    <div class="image-thumbnail-container mt-2">
                        <!-- Image thumbnails will be added here -->
                    </div>
                </div>

                <!-- Action Buttons (Top Right) -->
                <div class="absolute top-2 right-2 flex flex-col space-y-1">
                    <button title="Add Tweet Above" class="add-above-button btn-icon p-1 rounded-full text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm"><path d="m15 18-6-6 6-6"/><circle cx="12" cy="12" r="10"/></svg>
                    </button>
                    <button title="Add Tweet Below" class="add-below-button btn-icon p-1 rounded-full text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm"><path d="m9 18 6-6-6-6"/><circle cx="12" cy="12" r="10"/></svg>
                    </button>
                    <button title="Delete Tweet" class="delete-tweet-button btn-icon p-1 rounded-full text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 transition-colors">
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-sm"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    </button>
                </div>
            `;

            // Initialize image data for this new tweet
            setImagesForTweet(tweetId, tweetData.images || []);

            // Insert into DOM
            if (typeof index === 'number' && tweetContainer.children[index]) {
                tweetContainer.insertBefore(tweetElement, tweetContainer.children[index]);
            } else {
                tweetContainer.appendChild(tweetElement);
            }

            // Attach event listeners (including new image listeners)
            setTweetElementEvents(tweetElement);
            // Render initial thumbnails if any were passed in tweetData
            renderTweetImageThumbnails(tweetElement);
            // Apply styles
            applyDynamicStyles(tweetElement);

            // Initial update of UI state based on images
            updateImageUIState(tweetElement);

            // Update main preview and autosave
            updatePreview();
            autoSave(); // Will now save text AND images
            return tweetElement;
        }

        // NEW: Render thumbnails inside the tweet editor block
        function renderTweetImageThumbnails(tweetElement) {
            const container = tweetElement.querySelector('.image-thumbnail-container');
            if (!container) return;

            const tweetId = tweetElement.id;
            const images = getImagesForTweet(tweetId);
            container.innerHTML = ''; // Clear existing thumbs

            images.forEach((dataUrl, index) => {
                const thumbItem = document.createElement('div');
                thumbItem.className = 'image-thumbnail-item';
                thumbItem.innerHTML = `
                    <img src="${dataUrl}" alt="Thumbnail ${index + 1}">
                    <button title="Remove Image" class="remove-image-btn" data-index="${index}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                `;
                thumbItem.querySelector('.remove-image-btn').addEventListener('click', (event) => {
                     event.stopPropagation();
                     const imgIndexToRemove = parseInt(event.currentTarget.dataset.index, 10);
                     removeImageFromTweet(tweetElement, imgIndexToRemove);
                });
                container.appendChild(thumbItem);
            });
						 // Apply styles to the new remove buttons
						applyDynamicStyles(container);
        }

        // NEW: Update add button state and count indicator
        function updateImageUIState(tweetElement) {
            const images = getImagesForTweet(tweetElement.id);
            const count = images.length;
            const addButton = tweetElement.querySelector('.add-image-button');
            const countIndicator = tweetElement.querySelector('.image-count-indicator');
            const fileInput = tweetElement.querySelector('.image-file-input');

            if (addButton) {
                addButton.disabled = count >= MAX_IMAGES_PER_TWEET;
            }
            if (countIndicator) {
                countIndicator.textContent = `${count}/${MAX_IMAGES_PER_TWEET} images`;
            }
            if (fileInput) {
                // Ensure we don't exceed max when selecting multiple
                const remainingSlots = MAX_IMAGES_PER_TWEET - count;
                // Note: 'multiple' attribute doesn't directly support limiting *count*,
                // we handle this in the file selection logic. This just clears the input.
                fileInput.value = ''; // Reset file input
            }
        }

        // NEW: Handle image file selection
        function handleImageSelection(event) {
            const fileInput = event.target;
            const tweetElement = fileInput.closest('.tweet-container');
            if (!tweetElement) return;

            const tweetId = tweetElement.id;
            const existingImages = getImagesForTweet(tweetId);
            const files = Array.from(fileInput.files);
            const allowedNewFiles = MAX_IMAGES_PER_TWEET - existingImages.length;

            if (files.length === 0) return;

            let filesProcessed = 0;
            const newImageDataUrls = [...existingImages]; // Start with existing images

            files.slice(0, allowedNewFiles).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        newImageDataUrls.push(e.target.result);
                        filesProcessed++;
                        // Update only when all selected valid files are processed
                        if (filesProcessed === Math.min(files.length, allowedNewFiles)) {
                            setImagesForTweet(tweetId, newImageDataUrls);
                            renderTweetImageThumbnails(tweetElement);
                            updateImageUIState(tweetElement);
														playHapticFeedback();
                        }
                    };
                    reader.onerror = () => {
                        showNotification(`Error reading file: ${file.name}`, 'error');
                        filesProcessed++; // Count as processed even on error
                        if (filesProcessed === Math.min(files.length, allowedNewFiles)) {
                            // Still update with potentially partially added images if needed
                             setImagesForTweet(tweetId, newImageDataUrls);
                             renderTweetImageThumbnails(tweetElement);
                             updateImageUIState(tweetElement);
                        }
                    };
                    reader.readAsDataURL(file);
                } else {
                    showNotification(`File "${file.name}" is not a valid image type.`, 'warning');
                    filesProcessed++; // Count non-images as processed too
                     if (filesProcessed === Math.min(files.length, allowedNewFiles)) {
													// Update UI state even if only invalid files were 'processed'
													 setImagesForTweet(tweetId, newImageDataUrls); // Re-set (might be unchanged)
													 renderTweetImageThumbnails(tweetElement);
													 updateImageUIState(tweetElement);
											}
                }
            });

            // If more files were selected than allowed, show a warning
            if (files.length > allowedNewFiles) {
                showNotification(`You selected ${files.length} files, but only ${allowedNewFiles} more can be added (max ${MAX_IMAGES_PER_TWEET}).`, 'warning', 4000);
            }
             // Reset file input after processing
             fileInput.value = '';
        }

        // NEW: Remove an image from a tweet
        function removeImageFromTweet(tweetElement, indexToRemove) {
            const tweetId = tweetElement.id;
            const currentImages = getImagesForTweet(tweetId);
            if (indexToRemove >= 0 && indexToRemove < currentImages.length) {
                currentImages.splice(indexToRemove, 1);
                setImagesForTweet(tweetId, currentImages); // Update the central store
                renderTweetImageThumbnails(tweetElement); // Re-render thumbnails
                updateImageUIState(tweetElement); // Update button state/count
								playHapticFeedback();
            }
        }


        // MODIFIED: setTweetElementEvents to include image listeners
        function setTweetElementEvents(tweetElement) {
            // console.log("Setting events for tweet element:", tweetElement.id); // DEBUG
            const textarea = tweetElement.querySelector('.tweet-text');
            const countDisplay = tweetElement.querySelector('.character-count');
            const addAboveButton = tweetElement.querySelector('.add-above-button');
            const addBelowButton = tweetElement.querySelector('.add-below-button');
            const deleteButton = tweetElement.querySelector('.delete-tweet-button');
             // NEW Image elements
             const addImageButton = tweetElement.querySelector('.add-image-button');
             const imageFileInput = tweetElement.querySelector('.image-file-input');


            if (!textarea || !countDisplay || !addAboveButton || !addBelowButton || !deleteButton || !addImageButton || !imageFileInput) {
                console.error("Could not find all elements within tweetElement:", tweetElement);
                return;
            }

            // Textarea Input Listener
            textarea.addEventListener('input', () => {
                const length = textarea.value.length;
                countDisplay.textContent = `${length}/${MAX_TWEET_LENGTH}`;
                const isOverLimit = length > MAX_TWEET_LENGTH;
                countDisplay.classList.toggle('text-warning', isOverLimit);
                countDisplay.classList.toggle('dark:text-red-400', isOverLimit);
                countDisplay.classList.toggle('text-muted', !isOverLimit);
                updatePreview(); // Now updates mock-up preview
                autoSave();
            });

            // Add Image Button Listener - Triggers hidden file input
            addImageButton.addEventListener('click', (event) => {
                event.stopPropagation();
                if (!addImageButton.disabled) {
                    imageFileInput.click(); // Programmatically click the hidden input
                }
            });

            // Image File Input Listener
            imageFileInput.addEventListener('change', handleImageSelection);

            // Add Tweet Above/Below/Delete Listeners (adjusted slightly)
            addAboveButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const index = Array.from(tweetContainer.children).indexOf(tweetElement);
                const newTweet = createTweetElement({ text: '', images: [] }, index); // Create with empty data
                if (newTweet) newTweet.querySelector('textarea')?.focus();
                playHapticFeedback();
            });

            addBelowButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const index = Array.from(tweetContainer.children).indexOf(tweetElement);
                const newTweet = createTweetElement({ text: '', images: [] }, index + 1); // Create with empty data
                if (newTweet) newTweet.querySelector('textarea')?.focus();
                playHapticFeedback();
            });

            deleteButton.addEventListener('click', (event) => {
                event.stopPropagation();
                if (confirm('Are you sure you want to delete this tweet?')) {
                    const tweetId = tweetElement.id;
                    tweetElement.remove();
                    // NEW: Clean up image data for the deleted tweet
                    delete tweetImages[tweetId];
                    updatePreview(); // Update overall preview
                    autoSave(); // Update autosave
                    playHapticFeedback();
                    showNotification('Tweet deleted.', 'info', 1500);
                }
            });
        }

        // --- Update Preview (REWRITTEN for Twitter Mockup) ---
        function updatePreview() {
             // console.log("Updating mock-up preview..."); // DEBUG
             if (!previewContainer || !tweetContainer) return;

             previewContainer.innerHTML = ''; // Clear previous preview

             const tweetElements = Array.from(tweetContainer.querySelectorAll('.tweet-container'));

             if (tweetElements.length === 0) {
                 previewContainer.innerHTML = '<p class="text-muted italic text-center">Add tweets using the "Add Tweet" button.</p>';
                 return;
             }

             let hasContent = false;
             tweetElements.forEach((tweetElement, index) => {
                 const tweetId = tweetElement.id;
                 const textarea = tweetElement.querySelector('.tweet-text');
                 const text = textarea.value.trim();
                 const images = getImagesForTweet(tweetId);

                 if (text || images.length > 0) {
                     hasContent = true;

                     const previewMockup = document.createElement('div');
                     previewMockup.className = `tweet-preview-mockup image-count-${images.length}`; // Add class for image count styling

                     // --- Mockup Header ---
										 const header = document.createElement('div');
										 header.className = 'tweet-mockup-header';
										 header.innerHTML = `
												 <div class="tweet-mockup-avatar">
														 <img src="https://avatars.githubusercontent.com/u/86871974?v=4" alt="Hatchedboy Avatar">
												 </div>
												 <div class="tweet-mockup-author">
														 <div class="tweet-mockup-name">Hatchedboy</div>
														 <div class="tweet-mockup-username">@hatchedboy</div>
												 </div>
										 `;
										 previewMockup.appendChild(header);


                     // --- Mockup Content ---
                     const contentDiv = document.createElement('div');
                     contentDiv.className = 'tweet-mockup-content';
                     if (text) {
                         // Basic highlighting - same as before
                         const highlightedText = text
                             .replace(/</g, "&lt;").replace(/>/g, "&gt;")
                             .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" class="text-blue-500 dark:text-blue-400 hover:underline">$1</a>')
                             .replace(/#(\w+)/g, '<span class="text-blue-500 dark:text-blue-400">#$1</span>') // Use blue for hashtags like Twitter
                             .replace(/@(\w+)/g, '<span class="text-blue-500 dark:text-blue-400">@$1</span>'); // Use blue for mentions
                         contentDiv.innerHTML = `<p>${highlightedText}</p>`;
                     } else {
                         contentDiv.innerHTML = '<p class="text-muted italic">(Empty tweet text)</p>';
                     }
                     previewMockup.appendChild(contentDiv);

                     // --- Mockup Images ---
                     if (images.length > 0) {
                         const imagesContainer = document.createElement('div');
                         imagesContainer.className = 'tweet-mockup-images';
                         const imageGrid = document.createElement('div');
                         imageGrid.className = 'tweet-mockup-images-grid';

                         images.forEach((dataUrl) => {
                             const img = document.createElement('img');
                             img.src = dataUrl;
                             img.alt = 'Tweet image preview';
                             imageGrid.appendChild(img);
                         });
                         imagesContainer.appendChild(imageGrid);
                         previewMockup.appendChild(imagesContainer);
                     }

                     previewContainer.appendChild(previewMockup);
                 }
             });

              if (!hasContent && tweetElements.length > 0) {
                 previewContainer.innerHTML = '<p class="text-muted italic text-center">Start typing or add images in the boxes above to see the preview.</p>';
              }
         }


        // --- Library Functions (MODIFIED Storage Format) ---

        // MODIFIED: updateLibraryDisplay to handle new tweet format potentially
        function updateLibraryDisplay() {
             console.log("Updating library display..."); // DEBUG
             if (!libraryContainer) return;
             libraryContainer.innerHTML = '';

             const sortedTitles = Object.keys(library).sort((a, b) => a.localeCompare(b));

             if (sortedTitles.length === 0) {
                 libraryContainer.innerHTML = '<p class="text-muted italic text-center">Your saved threads will appear here.</p>';
                 return;
             }

             sortedTitles.forEach(title => {
                 const versions = library[title]?.versions;
                 if (!versions || versions.length === 0) return;

                 const threadGroup = document.createElement('div');
                 threadGroup.className = 'library-thread-group border border-color rounded-lg overflow-hidden';

                 const titleHeader = document.createElement('h3');
                 titleHeader.className = 'text-lg font-semibold text-secondary p-3 bg-gray-50 dark:bg-gray-700/50 border-b border-color';
                 titleHeader.textContent = title;
                 threadGroup.appendChild(titleHeader);

                 const versionsList = document.createElement('div');
                 versionsList.className = 'divide-y divide-gray-200 dark:divide-gray-600';
                 threadGroup.appendChild(versionsList);

                 const sortedVersions = [...versions].sort((a, b) => b.timestamp - a.timestamp);

                 sortedVersions.forEach((version, displayIndex) => {
                     const versionElement = document.createElement('div');
                     const bgColor = displayIndex % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50 dark:bg-gray-700/50';
                     versionElement.className = `library-version-item p-3 ${bgColor} flex flex-col sm:flex-row sm:items-center gap-3`;

                     const contentSection = document.createElement('div');
                     contentSection.className = 'flex-grow space-y-1 mb-2 sm:mb-0';

                     const timeWrapper = document.createElement('div');
                     timeWrapper.className = 'flex items-center gap-2 text-sm text-muted';
                     const timeSpan = document.createElement('span');
                     timeSpan.textContent = new Date(version.timestamp).toLocaleString();
                     timeWrapper.appendChild(timeSpan);
                     if (displayIndex === 0) {
                         const latestBadge = document.createElement('span');
                         latestBadge.className = 'latest-badge bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full dark:bg-green-900 dark:text-green-300';
                         latestBadge.textContent = 'Latest';
                         timeWrapper.appendChild(latestBadge);
                     }
                     contentSection.appendChild(timeWrapper);

                     const previewElement = document.createElement('p');
                     previewElement.className = 'text-xs text-gray-600 dark:text-gray-400 italic truncate';
                     previewElement.textContent = version.concept || '(No concept provided)';
                     previewElement.title = version.concept || '(No concept provided)';
                     contentSection.appendChild(previewElement);

                     // NEW: Indicate if tweets have images
                     const hasImages = version.tweets.some(t => t.images && t.images.length > 0);
                     if (hasImages) {
                         const imageIndicator = document.createElement('span');
                         imageIndicator.className = 'text-xs text-blue-500 dark:text-blue-400 ml-1';
                         imageIndicator.textContent = '(includes images)';
                         previewElement.appendChild(imageIndicator);
                     }


                     versionElement.appendChild(contentSection);

                     const actionsSection = document.createElement('div');
                     actionsSection.className = 'flex flex-col sm:flex-row flex-shrink-0 gap-2 items-end sm:items-center sm:justify-end';

                     const loadButton = document.createElement('button');
                     loadButton.className = 'load-entry btn btn-xs bg-blue-600 hover:bg-blue-700 w-full sm:w-auto';
                     loadButton.title = 'Load this version into the editor';
                     loadButton.dataset.title = title;
                     loadButton.dataset.timestamp = version.timestamp;
                     loadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-xs mr-1"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>Load`;
                     loadButton.addEventListener('click', (event) => { event.stopPropagation(); const t = event.currentTarget.dataset.title; const ts = event.currentTarget.dataset.timestamp; loadThreadFromLibrary(t, ts); playHapticFeedback(); });
                     actionsSection.appendChild(loadButton);

                     const exportButton = document.createElement('button');
                     exportButton.className = 'export-entry btn btn-xs bg-green-600 hover:bg-green-700 w-full sm:w-auto';
                     exportButton.title = 'Export this version as TXT (Images will be omitted)'; // Clarify TXT limitation
                     exportButton.dataset.title = title;
                     exportButton.dataset.timestamp = version.timestamp;
                     exportButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-xs mr-1"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>Export TXT`;
                     exportButton.addEventListener('click', (event) => { event.stopPropagation(); const t = event.currentTarget.dataset.title; const ts = event.currentTarget.dataset.timestamp; exportSpecificThreadVersion(t, ts); playHapticFeedback(); });
                     actionsSection.appendChild(exportButton);

                     const deleteButton = document.createElement('button');
                     deleteButton.className = 'delete-entry btn btn-xs bg-red-600 hover:bg-red-700 w-full sm:w-auto';
                     deleteButton.title = 'Delete this version';
                     deleteButton.dataset.title = title;
                     deleteButton.dataset.timestamp = version.timestamp;
                     deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-xs mr-1"><circle cx="12" cy="12" r="10"/><line x1="15" x2="9" y1="9" y2="15"/><line x1="9" x2="15" y1="9" y2="15"/></svg>Delete`;
                     deleteButton.addEventListener('click', (event) => { event.stopPropagation(); const t = event.currentTarget.dataset.title; const ts = event.currentTarget.dataset.timestamp; deleteThreadVersion(t, ts); playHapticFeedback(); });
                     actionsSection.appendChild(deleteButton);

                     versionElement.appendChild(actionsSection);
                     versionsList.appendChild(versionElement);
                 });

                 libraryContainer.appendChild(threadGroup);
                 applyDynamicStyles(threadGroup);
             });
         }

        // MODIFIED: saveToLibrary to package tweets with images
        async function saveToLibrary() {
            console.log("Attempting to save to library..."); // DEBUG
            if (!threadTitleInput) return;
            const title = threadTitleInput.value.trim();
            if (!title) {
                showNotification('Please enter a thread title before saving.', 'error');
                threadTitleInput.focus();
                return;
            }

            let libraryEntry = await loadFromDB(LIBRARY_STORE_NAME, title);
            if (!libraryEntry) {
                libraryEntry = { title: title, versions: [] };
            }

             // NEW: Package tweets including text and images
             const currentTweetsData = Array.from(tweetContainer?.querySelectorAll('.tweet-container') || []).map(tweetElement => {
                 const tweetId = tweetElement.id;
                 const textarea = tweetElement.querySelector('.tweet-text');
                 return {
                     text: textarea ? textarea.value : '',
                     images: getImagesForTweet(tweetId) // Get images using helper
                 };
             });

            const newVersionData = {
                concept: threadConceptInput?.value.trim() || '',
                tweets: currentTweetsData, // Store the array of tweet objects
                timestamp: Date.now()
            };
            // console.log("New version data for library:", newVersionData); // DEBUG

            // More robust duplicate check comparing serialized tweets data
						// Note: Comparing large dataURLs in JSON.stringify might be slow for many images/tweets
						const isDuplicate = libraryEntry.versions.some(v =>
								 v.concept === newVersionData.concept &&
								 JSON.stringify(v.tweets) === JSON.stringify(newVersionData.tweets) // Compare stringified tweet objects
						 );


            if (!isDuplicate) {
                libraryEntry.versions.push(newVersionData);
                try {
                    await saveToDB(LIBRARY_STORE_NAME, libraryEntry);
                    library[title] = libraryEntry; // Update in-memory cache
                    updateLibraryDisplay();
                    showNotification(`Thread "${title}" (New Version) saved to library.`, 'success');
                    playHapticFeedback();
                } catch (e) {
                    console.error("Error saving library entry:", e);
                    showNotification("Could not save library entry.", "error");
                }
            } else {
                // console.log("Duplicate version detected, not saving."); // DEBUG
                showNotification(`This exact version of "${title}" is already saved.`, 'info');
            }
        }

        // MODIFIED: loadThreadFromLibrary to handle new tweet format
        function loadThreadFromLibrary(title, timestamp) {
            console.log(`Loading library version: ${title}, timestamp ${timestamp}`); // DEBUG
            const versionTimestamp = parseInt(timestamp, 10);
            if (isNaN(versionTimestamp)) {
                showNotification("Error loading thread: Invalid version identifier.", "error"); return;
            }

            const versionToLoad = library[title]?.versions?.find(v => v.timestamp === versionTimestamp);

            if (versionToLoad && threadTitleInput && threadConceptInput && tweetContainer) {
                threadTitleInput.value = title;
                threadConceptInput.value = versionToLoad.concept;
                tweetContainer.innerHTML = ''; // Clear existing tweets
                tweetImages = {}; // Clear existing image data store

                // Create tweet elements using the loaded data (which includes images)
                versionToLoad.tweets.forEach(tweetData => {
                    // Ensure tweetData is an object; fallback for older saves without images
                    const data = typeof tweetData === 'object' ? tweetData : { text: tweetData, images: [] };
                    createTweetElement(data); // Pass the whole object
                });

                updatePreview(); // Update the mock-up preview
                autoSave(); // Update autosave DB

                 if(libraryModal) libraryModal.style.display = 'none';
                showNotification(`Loaded "${title}" (Saved: ${new Date(versionTimestamp).toLocaleString()}).`, 'success');
            } else {
                console.error("Failed to load from library - version/elements missing:", title, versionTimestamp); // DEBUG
                showNotification(`Error loading thread "${title}". Version not found or elements missing.`, 'error');
            }
        }

        // MODIFIED: exportSpecificThreadVersion to clarify image omission
        function exportSpecificThreadVersion(title, timestamp) {
            console.log(`Exporting library version as TXT: ${title}, timestamp ${timestamp}`); // DEBUG
            const versionTimestamp = parseInt(timestamp, 10);
            if (isNaN(versionTimestamp)) {
                showNotification("Error exporting thread: Invalid version identifier.", "error"); return;
            }

            const versionToExport = library[title]?.versions?.find(v => v.timestamp === versionTimestamp);

            if (versionToExport) {
                 // Create TXT content, explicitly stating images are not included
                let content = `Thread Title: ${title}\n\nThread Concept:\n${versionToExport.concept || '(No concept)'}\n\nTweets (Images are not included in TXT export):\n\n`;
                versionToExport.tweets.forEach((tweetData, idx) => {
                    // Handle old string format vs new object format
                    const text = typeof tweetData === 'object' ? tweetData.text : tweetData;
                    content += `${idx + 1}. ${text || '(Empty tweet)'}\n\n`;
                });
                content += `\n\nSaved on: ${new Date(versionTimestamp).toLocaleString()}`;

                downloadFile(`${title}_${versionTimestamp}_NoImages.txt`, content, 'text/plain'); // Add NoImages to filename
                showNotification(`Exported "${title}" as TXT (Images omitted).`, 'success');
            } else {
                showNotification(`Error exporting thread "${title}" as TXT. Version not found.`, 'error');
            }
        }

        // MODIFIED: deleteThreadVersion (no structural change, but library format handled)
        async function deleteThreadVersion(title, timestamp) {
            console.log(`Deleting library version: ${title}, timestamp ${timestamp}`); // DEBUG
            const versionTimestamp = parseInt(timestamp, 10);
            if (isNaN(versionTimestamp)) {
                showNotification("Error deleting thread: Invalid version identifier.", "error"); return;
            }

            // Load fresh from DB to ensure consistency before delete
            let libraryEntry = await loadFromDB(LIBRARY_STORE_NAME, title);
            if (!libraryEntry || !libraryEntry.versions) {
                 showNotification(`Error deleting thread "${title}". Entry not found.`, 'error'); return;
            }

            const versionIndex = libraryEntry.versions.findIndex(v => v.timestamp === versionTimestamp);
            if (versionIndex === -1) {
                 showNotification(`Error deleting thread "${title}". Version not found.`, 'error'); return;
            }

            if (confirm(`Are you sure you want to delete this version of "${title}" (Saved: ${new Date(versionTimestamp).toLocaleString()})? This cannot be undone.`)) {
                libraryEntry.versions.splice(versionIndex, 1);
                try {
                    if (libraryEntry.versions.length === 0) {
                        await deleteFromDB(LIBRARY_STORE_NAME, title);
                        delete library[title]; // Remove from in-memory
                    } else {
                        await saveToDB(LIBRARY_STORE_NAME, libraryEntry);
                        library[title] = libraryEntry; // Update in-memory
                    }
                    updateLibraryDisplay();
                    showNotification(`Deleted version of "${title}" (Saved: ${new Date(versionTimestamp).toLocaleString()}).`, 'success');
                } catch (e) {
                    console.error("Error updating library DB after deletion:", e);
                    showNotification("Could not update library after deletion.", "error");
                     // Force reload from DB to resync memory on error
                     await loadLibraryFromDB();
                     updateLibraryDisplay();
                }
            }
        }

        // MODIFIED: exportLibrary (adjusts format, aware of new tweet structure)
        async function exportLibrary() {
             console.log("Exporting entire library..."); // DEBUG
             const allLibraryEntries = await loadAllFromDB(LIBRARY_STORE_NAME);
             if (!allLibraryEntries || allLibraryEntries.length === 0) {
                 showNotification('Library is empty. Nothing to export.', 'info'); return;
             }

						// Export format: Keep as array of { title: string, versions: [...] } for easier import merging.
            // The versions array ALREADY contains the tweet objects with images.
             // const exportData = allLibraryEntries; // No transformation needed

             try {
                 // Use replacer to potentially handle very large dataURLs if needed in future, but likely fine for now.
                 const libraryJson = JSON.stringify(allLibraryEntries, null, 2);
                 downloadFile('280Thread_Library_Export_v2.json', libraryJson, 'application/json'); // v2 indicates image support
                 showNotification('Library exported successfully (including images).', 'success');
             } catch (e) {
                  console.error("Error stringifying library for export:", e);
                  showNotification("Could not prepare library for export.", "error");
						 			// Consider specific warnings for QUOTA_EXCEEDED_ERR if stringification fails due to size
             }
        }

        // MODIFIED: importLibrary (expects new format, merges carefully)
        async function importLibrary(file) {
            console.log("Importing library from file:", file?.name); // DEBUG
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    if (!e.target.result) throw new Error("File is empty.");
                    const importedLibraryArray = JSON.parse(e.target.result); // Expects array [{ title: '', versions: [] }, ...]
                    // console.log("Parsed imported library data:", importedLibraryArray); // DEBUG

                     if (!Array.isArray(importedLibraryArray)) {
                         throw new Error('Invalid library format. Expected a JSON array.');
                     }

                    let importedCount = 0;
                    let mergedCount = 0;
                    let titlesProcessed = 0;

                    const existingEntriesArray = await loadAllFromDB(LIBRARY_STORE_NAME);
                    const existingLibraryMap = existingEntriesArray.reduce((map, entry) => {
                        map[entry.title] = entry;
                        return map;
                    }, {});

                    for (const importedEntry of importedLibraryArray) {
                        if (!importedEntry || typeof importedEntry.title !== 'string' || !Array.isArray(importedEntry.versions)) {
                            console.warn(`Skipping invalid entry structure during import:`, importedEntry); continue; // Skip invalid top-level entries
                        }

                        const title = importedEntry.title;
                        titlesProcessed++;

                        let targetEntry = existingLibraryMap[title];
                        let isNewEntry = false;
                        if (!targetEntry) {
                            targetEntry = { title: title, versions: [] };
                            isNewEntry = true;
                        }

                        let versionsAddedToThisTitle = 0;
                        importedEntry.versions.forEach(importedVersion => {
                            // Validate imported version structure (basic check)
                            if (importedVersion?.timestamp && Array.isArray(importedVersion.tweets)) {
                                // Check for duplicate timestamp within this specific title
                                if (!targetEntry.versions.some(existing => existing.timestamp === importedVersion.timestamp)) {
                                     // **Crucially, validate tweet format inside version**
                                     const sanitizedTweets = importedVersion.tweets.map(t => ({
                                         text: (typeof t === 'object' && t?.text) ? String(t.text) : (typeof t === 'string' ? t : ''), // Ensure text is string or empty
                                         images: (typeof t === 'object' && Array.isArray(t.images)) ? t.images.filter(img => typeof img === 'string' && img.startsWith('data:image/')) : [] // Ensure images is array of valid dataURLs
                                     }));

                                    targetEntry.versions.push({
                                        ...importedVersion, // Keep other potential fields
                                        tweets: sanitizedTweets, // Use sanitized tweets
                                        timestamp: importedVersion.timestamp // Ensure timestamp is present
                                    }); // Add the validated version
                                    versionsAddedToThisTitle++;
                                }
                            } else {
                                console.warn(`Skipping version with invalid structure/timestamp for title "${title}":`, importedVersion);
                            }
                        });

                        if (versionsAddedToThisTitle > 0 || (isNewEntry && targetEntry.versions.length > 0)) {
                            try {
                                await saveToDB(LIBRARY_STORE_NAME, targetEntry);
                                library[title] = targetEntry; // Update in-memory cache
                                mergedCount++;
                                importedCount += versionsAddedToThisTitle;
                            } catch(saveError) {
                                console.error(`Error saving merged entry for title "${title}" during import:`, saveError);
                                showNotification(`Error saving imported data for "${title}".`, "error");
                            }
                        }
                    } // End loop through imported entries

                    updateLibraryDisplay();
                    showNotification(`Library import complete. Processed ${titlesProcessed} titles, added ${importedCount} new versions across ${mergedCount} entries.`, 'success', 5000);
                    playHapticFeedback();

                } catch (error) {
                    showNotification(`Error importing library: ${error.message}`, 'error', 5000);
                    console.error("Library import error:", error);
                }
            };
            reader.onerror = (err) => showNotification('Error reading library file.', 'error');
            reader.readAsText(file);
            if(importLibraryFileInput) importLibraryFileInput.value = '';
        }


        // --- TXT Import/Export (MODIFIED to warn about images) ---
        function saveThreadToTxt() {
            console.log("Saving current thread as TXT..."); // DEBUG
            if (!threadTitleInput || !threadConceptInput || !tweetContainer) return;

            const title = threadTitleInput.value.trim() || 'Untitled Thread';
            const concept = threadConceptInput.value.trim();
            let content = `Thread Title: ${title}\n\nThread Concept:\n${concept || '(No concept)'}\n\nTweets (Images are NOT included in TXT export):\n\n`; // Clarify limitation
            let tweetCount = 0;

            Array.from(tweetContainer.querySelectorAll('.tweet-container')).forEach((tweetElement, index) => {
                const textarea = tweetElement.querySelector('.tweet-text');
                const tweetText = textarea ? textarea.value : '';
                const images = getImagesForTweet(tweetElement.id);

                 content += `${index + 1}. ${tweetText}`;
                 // Optionally indicate if the original tweet had images
                 if (images.length > 0) {
                     content += ` [Had ${images.length} image(s)]`;
                 }
                 content += `\n\n`;

                if (tweetText.trim() || images.length > 0) tweetCount++;
            });

            if (tweetCount === 0 && !concept && title === 'Untitled Thread') {
                showNotification('Nothing to export. Add some content first.', 'info'); return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadFile(`${title}_NoImages_${timestamp}.txt`, content, 'text/plain'); // Add NoImages to filename
            showNotification('Thread exported as TXT (Images omitted).', 'success');
        }

        // importFromTxt remains the same - it cannot import images from TXT
        function importFromTxt(file) {
            console.log("Importing from TXT file (images cannot be imported):", file?.name); // DEBUG
             if (!file || !threadTitleInput || !threadConceptInput || !tweetContainer) return;

            const reader = new FileReader();
            reader.onload = function(e) {
						 // Clear existing content AND image data before importing TXT
							if(threadTitleInput) threadTitleInput.value = '';
              if(threadConceptInput) threadConceptInput.value = '';
              if(tweetContainer) tweetContainer.innerHTML = '';
							tweetImages = {}; // Clear image data

                try {
                    if (!e.target.result) throw new Error("File is empty.");
                    const content = e.target.result;
                    const lines = content.split('\n');
                    let title = '';
                    let concept = '';
                    const tweets = [];
                    let currentSection = '';
                    let currentTweet = '';

                    lines.forEach(line => {
                        const trimmedLine = line.trim();
                        if (trimmedLine.startsWith('Thread Title:')) {
                            title = trimmedLine.substring('Thread Title:'.length).trim();
                            currentSection = 'title';
                        } else if (trimmedLine.startsWith('Thread Concept:')) {
                            currentSection = 'concept';
                            concept = '';
                        } else if (trimmedLine.startsWith('Tweets:')) {
                            currentSection = 'tweets';
                            currentTweet = '';
                        }
                        else if (currentSection === 'concept') {
                            // Skip the initial "Thread Concept:" line itself if present on next line
                            if (line.trim() !== 'Thread Concept:') {
                                concept += line + '\n';
                             }
                        } else if (currentSection === 'tweets') {
                            // Handle lines like "1. Tweet text [Had image(s)]"
                            if (/^\d+\.\s*/.test(line)) {
                                if (currentTweet.trim()) tweets.push(currentTweet.trim()); // Push previous completed tweet
                                currentTweet = line.replace(/^\d+\.\s*/, '').replace(/\[Had \d+ image\(s\)\]$/, '').trim(); // Extract text, remove image marker
                            } else if (trimmedLine && !trimmedLine.startsWith('Saved on:')) { // Append non-empty lines to current tweet
                                currentTweet += '\n' + line;
                            }
                        }
                    });
                    if (currentTweet.trim()) tweets.push(currentTweet.trim()); // Push the last tweet


                    threadTitleInput.value = title;
                    threadConceptInput.value = concept.trim(); // Trim the collected concept
                    // tweetContainer already cleared
                    tweets.forEach(tweetText => createTweetElement({ text: tweetText, images: [] })); // Create tweets WITHOUT images

                    if(tweets.length === 0) { // Ensure at least one box if import was empty
                         createTweetElement();
                    }

                    updatePreview();
                    autoSave();
                    showNotification('Thread imported from TXT. Images (if any) were not included.', 'success', 4000); // Updated message
                    playHapticFeedback();

                } catch (error) {
                    showNotification(`Error parsing TXT file: ${error.message}`, 'error', 5000);
                     // Ensure a clean slate on error
                     if(threadTitleInput) threadTitleInput.value = '';
                     if(threadConceptInput) threadConceptInput.value = '';
                     if(tweetContainer) tweetContainer.innerHTML = '';
                     tweetImages = {};
                     createTweetElement();
                     updatePreview();
                }
            };
             reader.onerror = (err) => showNotification('Error reading TXT file.', 'error');
             reader.readAsText(file);
             if(importThreadFileInput) importThreadFileInput.value = '';
        }


        // --- Utility Functions (No changes) ---
        function downloadFile(filename, content, mimeType) {
            try {
                 const blob = new Blob([content], { type: mimeType });
                 const link = document.createElement('a');
                 link.href = URL.createObjectURL(blob);
                 link.download = filename;
                 document.body.appendChild(link);
                 link.click();
                 document.body.removeChild(link);
                 URL.revokeObjectURL(link.href);
            } catch (e) {
                showNotification("File download failed.", "error");
            }
        }

        function playHapticFeedback() {
            if ('vibrate' in navigator) {
                try { navigator.vibrate(50); } catch (e) { /* Ignore */ }
            }
        }

        // --- AutoSave using IndexedDB (MODIFIED for images) ---
        async function autoSave() {
            // console.log("Autosaving..."); // DEBUG (noisy)
            if (!threadTitleInput || !threadConceptInput || !tweetContainer) return;

             // Package tweets including text and images for autosave
             const currentTweetsData = Array.from(tweetContainer.querySelectorAll('.tweet-container')).map(tweetElement => {
                 const tweetId = tweetElement.id;
                 const textarea = tweetElement.querySelector('.tweet-text');
                 return {
                     text: textarea ? textarea.value : '',
                     images: getImagesForTweet(tweetId) // Get current images
                 };
             });

            const threadData = {
                title: threadTitleInput.value,
                concept: threadConceptInput.value,
                tweets: currentTweetsData, // Save the array of tweet objects
                timestamp: Date.now()
            };

            const autoSaveEntry = { id: AUTOSAVE_KEY, data: threadData };

            try {
                 await saveToDB(AUTOSAVE_STORE_NAME, autoSaveEntry);
                 // console.log("Autosave successful"); // DEBUG (noisy)
            } catch (e) {
                 console.error("Error during autosave:", e);
                 showNotification("Could not auto-save.", "error");
            }
        }

        // MODIFIED: loadAutoSave to handle images
        async function loadAutoSave() {
            console.log("Loading autosave data..."); // DEBUG
             if (!threadTitleInput || !threadConceptInput || !tweetContainer) return;

             tweetContainer.innerHTML = ''; // Clear existing tweets first
             tweetImages = {}; // Clear existing image data store

            try {
                const savedEntry = await loadFromDB(AUTOSAVE_STORE_NAME, AUTOSAVE_KEY);

                if (savedEntry && savedEntry.data) {
                    console.log("Found autosave data.", savedEntry.data); // DEBUG
                    const threadData = savedEntry.data;
                    threadTitleInput.value = threadData.title || '';
                    threadConceptInput.value = threadData.concept || '';

                    if (threadData.tweets?.length > 0) {
                        threadData.tweets.forEach(tweetData => {
                             // Ensure tweetData is object (fallback for older autosaves)
                             const data = typeof tweetData === 'object' ? tweetData : { text: tweetData, images: [] };
                             createTweetElement(data); // Create tweet element with text and images
                         });
                    } else {
                         createTweetElement(); // Start with one empty if autosave had no tweets
                    }
                    updatePreview(); // Update mock-up preview
                    console.log(`Restored autosave from ${new Date(threadData.timestamp).toLocaleString()}`); // DEBUG
                } else {
                    console.log("No autosave data found, creating initial tweet."); // DEBUG
                    createTweetElement(); // Start fresh with one tweet
                     updatePreview();
                }
            } catch (e) {
                console.error("Error loading autosave:", e);
                showNotification("Could not restore auto-saved session.", "error");
                createTweetElement(); // Ensure one tweet box exists on error
                updatePreview();
                 // Clear potentially corrupted autosave
                 try { await deleteFromDB(AUTOSAVE_STORE_NAME, AUTOSAVE_KEY); } catch (removeError) { /* Ignore */ }
            }
        }


        // MODIFIED: loadLibraryFromDB (no structural change, just awareness of format)
        async function loadLibraryFromDB() {
            console.log("Loading library from IndexedDB into memory..."); // DEBUG
            try {
                const allEntries = await loadAllFromDB(LIBRARY_STORE_NAME);
                // Store as map { title: { title: '...', versions: [...] } }
                library = allEntries.reduce((map, entry) => {
                    // Optional: Add validation here if needed for older data formats
                    map[entry.title] = entry;
                    return map;
                 }, {});
                console.log("Library loaded into memory:", Object.keys(library).length, "entries"); // DEBUG
            } catch (e) {
                console.error("Error loading library from IndexedDB:", e);
                showNotification("Could not load thread library.", "error");
                library = {}; // Reset in-memory library
            }
        }

        // --- Theme Toggling (No changes) ---
        function toggleTheme() {
             if (!themeToggleBtn) return;
             document.documentElement.classList.toggle('dark');
             const isDarkMode = document.documentElement.classList.contains('dark');
             try { localStorage.setItem('theme', isDarkMode ? 'dark' : 'light'); } catch (e) { /* Ignore */ }
             if (isDarkMode) {
                 themeToggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon w-5 h-5"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>`;
             } else {
                 themeToggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon w-5 h-5"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`;
             }
             playHapticFeedback();
         }

        // --- Apply Dynamic Styles (No changes) ---
        function applyDynamicStyles(parentElement = document) {
            const baseBtnClasses = ['text-white','font-semibold','py-2','px-4','rounded-md','shadow','transition-all','duration-200','ease-in-out','transform','hover:scale-105','flex','items-center','justify-center'];
            const btnSmClassesRemove = ['py-2','px-4'];
            const btnSmClassesAdd = ['py-1','px-3','text-sm'];
            const btnXsClassesRemove = ['py-2','px-4','font-semibold'];
            const btnXsClassesAdd = ['py-1','px-2','text-xs','font-medium'];
            const btnIconClassesAdd = ['transition-colors', 'duration-150']; // For icon-only buttons like add/delete image

            parentElement.querySelectorAll('.btn:not(.btn-sm):not(.btn-xs)').forEach(button => button.classList.add(...baseBtnClasses));
            parentElement.querySelectorAll('.btn-sm').forEach(button => { button.classList.add(...baseBtnClasses); button.classList.remove(...btnSmClassesRemove); button.classList.add(...btnSmClassesAdd); });
            parentElement.querySelectorAll('.btn-xs').forEach(button => { button.classList.add(...baseBtnClasses); button.classList.remove(...btnXsClassesRemove); button.classList.add(...btnXsClassesAdd); });
						// Apply to simple icon buttons (like add/remove image, add/delete tweet)
            parentElement.querySelectorAll('.btn-icon').forEach(button => button.classList.add(...btnIconClassesAdd));
         }

        // --- Initialization (MODIFIED) ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM loaded."); // DEBUG

            // Cache DOM elements
            threadTitleInput = document.getElementById('threadTitle');
            threadConceptInput = document.getElementById('threadConcept');
            tweetContainer = document.getElementById('tweetContainer');
            previewContainer = document.getElementById('previewContainer');
            libraryModal = document.getElementById('libraryModal');
            libraryContainer = document.getElementById('libraryContainer');
            importThreadFileInput = document.getElementById('importThreadFile');
            importLibraryFileInput = document.getElementById('importLibraryFile');
            notificationArea = document.getElementById('notificationArea');
            themeToggleBtn = document.getElementById('themeToggle');
            console.log("DOM elements cached."); // DEBUG

            applyTheme(); // Initial theme

            try {
                await openDB();
                await loadLibraryFromDB();
                await loadAutoSave(); // Loads editor state including images
            } catch (err) {
                console.error("Initialization Error:", err);
                showNotification("Error initializing app data.", "error");
                if (!tweetContainer.hasChildNodes()) createTweetElement(); // Fallback
                updatePreview();
            }

            applyDynamicStyles(); // Initial styles

            // --- Attach Event Listeners ---
            console.log("Attaching main event listeners..."); // DEBUG
            document.getElementById('addTweetBtn')?.addEventListener('click', () => {
                const newTweet = createTweetElement(); // Creates empty tweet
                newTweet?.querySelector('textarea')?.focus();
                playHapticFeedback();
            });
            document.getElementById('saveThreadBtn')?.addEventListener('click', () => { saveThreadToTxt(); playHapticFeedback(); });
            document.getElementById('importThreadBtn')?.addEventListener('click', () => { importThreadFileInput?.click(); playHapticFeedback(); });
            importThreadFileInput?.addEventListener('change', event => { if (event.target.files.length > 0) importFromTxt(event.target.files[0]); });

            document.getElementById('clearAllBtn')?.addEventListener('click', async () => {
                if (confirm('Are you sure you want to clear the current thread (title, concept, tweets, and images)? This will also clear the auto-save.')) {
                    if(threadTitleInput) threadTitleInput.value = '';
                    if(threadConceptInput) threadConceptInput.value = '';
                    if(tweetContainer) tweetContainer.innerHTML = '';
                    tweetImages = {}; // CLEAR IMAGE DATA
                    createTweetElement(); // Add back one empty tweet
                    updatePreview();
                    try {
                        await deleteFromDB(AUTOSAVE_STORE_NAME, AUTOSAVE_KEY);
                        showNotification('Thread cleared.', 'info');
                    } catch (clearError) {
                        showNotification('Thread cleared, but failed to clear auto-save.', 'error');
                    }
                    playHapticFeedback();
                }
            });

            document.getElementById('saveToLibraryBtn')?.addEventListener('click', () => { saveToLibrary(); playHapticFeedback(); }); // saveToLibrary is async
            document.getElementById('openLibraryBtn')?.addEventListener('click', () => {
                updateLibraryDisplay(); // Uses in-memory cache
                if(libraryModal) libraryModal.style.display = 'flex';
                playHapticFeedback();
            });
            document.getElementById('closeLibraryBtn')?.addEventListener('click', () => { if(libraryModal) libraryModal.style.display = 'none'; playHapticFeedback(); });
            document.getElementById('exportLibraryBtn')?.addEventListener('click', () => { exportLibrary(); playHapticFeedback(); }); // exportLibrary is async
            document.getElementById('importLibraryBtnModal')?.addEventListener('click', () => { importLibraryFileInput?.click(); playHapticFeedback(); });
            importLibraryFileInput?.addEventListener('change', event => { if (event.target.files.length > 0) importLibrary(event.target.files[0]); }); // importLibrary is async

            themeToggleBtn?.addEventListener('click', toggleTheme);
            threadTitleInput?.addEventListener('input', autoSave); // AutoSave is async
            threadConceptInput?.addEventListener('input', autoSave); // AutoSave is async

            console.log("Event listeners attached."); // DEBUG
            console.log("App Initialized."); // DEBUG
        });

    </script>
</body>
</html>
